<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title>Mini OAuth Test App</title>
</head>

<body>
    <h1>OAuth Client App</h1>
    <button onclick="startAuth()">üîê Login with Mini OAuth</button>

    <h2>Token Response</h2>
    <pre id="output"></pre>
    <div id="error" style="color: red;"></div>

    <script>
        const clientId = "demo-client";
        const redirectUri = "http://localhost:3000";
        const authServer = "http://localhost:8080";
        const scope = "read write";  // Ajout des scopes ici

        // Utilitaires PKCE
        async function generateCodeVerifier() {
            const array = new Uint8Array(32);
            crypto.getRandomValues(array);
            return btoa(String.fromCharCode.apply(null, array))
                .replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
        }

        // Fonction de hachage SHA-256 avec v√©rification de disponibilit√©
        async function sha256(text) {
            try {
                // V√©rifier si crypto.subtle est disponible (contexte s√©curis√©)
                if (window.crypto && window.crypto.subtle) {
                    const encoder = new TextEncoder();
                    const data = encoder.encode(text);
                    const hash = await window.crypto.subtle.digest("SHA-256", data);
                    return new Uint8Array(hash);
                } else {
                    // Utilisation d'une alternative pour les contextes non-HTTPS
                    console.warn("Web Crypto API non disponible. Utilisation d'une m√©thode alternative.");
                    return simpleHash(text);
                }
            } catch (error) {
                console.error("Erreur lors du hachage:", error);
                document.getElementById("error").textContent = "Erreur de hachage: " + error.message;
                throw error;
            }
        }

        // M√©thode alternative de hachage simple pour les contextes non-HTTPS
        // Note: Ceci n'est pas cryptographiquement s√©curis√©, uniquement pour le d√©veloppement
        function simpleHash(str) {
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                const char = str.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash; // Convert to 32bit integer
            }
            // Cr√©er un tableau de 32 octets √† partir du hash
            const result = new Uint8Array(32);
            for (let i = 0; i < 32; i++) {
                result[i] = (hash >> (i % 8)) & 0xFF;
            }
            return result;
        }

        async function generateCodeChallenge(verifier) {
            try {
                const hashed = await sha256(verifier);
                return btoa(String.fromCharCode.apply(null, [...hashed]))
                    .replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
            } catch (error) {
                console.error("Erreur de g√©n√©ration du code challenge:", error);
                document.getElementById("error").textContent = "Erreur: " + error.message;
                throw error;
            }
        }

        // D√©marre l'auth
        async function startAuth() {
            try {
                const codeVerifier = await generateCodeVerifier();
                const codeChallenge = await generateCodeChallenge(codeVerifier);
                sessionStorage.setItem("code_verifier", codeVerifier);

                // Inclure les scopes dans l'URL d'autorisation
                const authUrl = `${authServer}/authorize?response_type=code&client_id=${clientId}&redirect_uri=${encodeURIComponent(redirectUri)}&code_challenge=${codeChallenge}&code_challenge_method=S256&scope=${encodeURIComponent(scope)}`;

                window.location.href = authUrl;  // Rediriger l'utilisateur
            } catch (error) {
                console.error("Erreur d'authentification:", error);
                document.getElementById("error").textContent = "Erreur d'authentification: " + error.message;
            }
        }

        // Si code dans l'URL ‚Üí √©change token
        window.onload = async function () {
            try {
                const params = new URLSearchParams(window.location.search);
                const code = params.get("code");
                if (code) {
                    const codeVerifier = sessionStorage.getItem("code_verifier");

                    const form = new URLSearchParams();
                    form.append("grant_type", "authorization_code");
                    form.append("code", code);
                    form.append("redirect_uri", redirectUri);
                    form.append("code_verifier", codeVerifier);

                    // Inclure les scopes dans le corps de la requ√™te de token
                    form.append("scope", scope);

                    const response = await fetch(`${authServer}/token`, {
                        method: "POST",
                        headers: { "Content-Type": "application/x-www-form-urlencoded" },
                        body: form
                    });

                    const json = await response.json();
                    document.getElementById("output").textContent = JSON.stringify(json, null, 2);
                }
            } catch (error) {
                console.error("Erreur lors de l'√©change du token:", error);
                document.getElementById("error").textContent = "Erreur: " + error.message;
            }
        }
    </script>

</body>

</html>